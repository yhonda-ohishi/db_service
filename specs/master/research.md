# 研究ドキュメント: Database-repo実装

## 技術選定

### ORM選定
**決定**: GORM v1.25.5
**理由**:
- 複合主キーのネイティブサポート
- 成熟したエコシステム
- マイグレーション機能内蔵
**検討した代替案**:
- sqlx: より低レベルだが、複合主キー処理が煩雑
- ent: より高機能だが、学習曲線が急峻

### gRPC実装パターン
**決定**: リポジトリパターン + サービス層分離
**理由**:
- データアクセスロジックの分離
- テスタビリティの向上
- モック作成の容易さ
**検討した代替案**:
- 直接DB接続: シンプルだが、テストが困難
- CQRS: 過剰な複雑性

### 環境設定管理
**決定**: godotenv + 環境変数
**理由**:
- 標準的なアプローチ
- Docker/Kubernetesとの互換性
- セキュアな秘密情報管理
**検討した代替案**:
- viper: 高機能だが、オーバースペック
- 直接環境変数: .envファイルの利便性なし

## データベース設計の考慮事項

### 複合主キー処理
dtako_uriage_keihiテーブルの複合主キー（srch_id, datetime, keihi_c）に対して：
- GORMのタグ指定で明示的に定義
- 検索時は全キーを指定
- 部分検索時はインデックス順序を考慮

### トランザクション管理
- デフォルトは自動コミット
- 複数テーブル更新時は明示的トランザクション
- エラー時の自動ロールバック実装

### 接続プーリング
- 最大接続数: 25（環境変数で調整可能）
- アイドルタイムアウト: 5分
- 最大ライフタイム: 1時間

## パフォーマンス最適化

### インデックス戦略
既存インデックスを活用：
- dtako_uriage_keihi: 複合インデックス活用
- etc_meisai: date_toインデックスで日付範囲検索最適化
- dtako_ferry_rows: 主キーのみ（追加インデックス検討）

### N+1問題対策
- Preloadでの関連データ一括取得
- JOINクエリの明示的使用
- バッチ処理での一括取得

## セキュリティ考慮事項

### 認証情報管理
- 環境変数からの読み込み必須
- デフォルト値の禁止
- 起動時の設定検証

### SQLインジェクション対策
- プリペアドステートメントの使用
- GORMのクエリビルダー活用
- 生SQLの最小化

## 解決された不明点

1. **テーブル定義**: C:\go\ryohi_sub_cal\mysqldataから完全に取得
2. **技術スタック**: Go 1.21 + gRPC + GORM確定
3. **パフォーマンス目標**: 200ms以内のレスポンス時間
4. **スケール**: 3テーブル、約10エンドポイント

## 次のステップ

Phase 1での実装：
- データモデル定義（data-model.md）
- Protocol Buffers契約（contracts/）
- クイックスタートガイド（quickstart.md）