// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             (unknown)
// source: ryohi.proto

package proto

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	DTakoUriageKeihiService_Create_FullMethodName = "/ryohi.DTakoUriageKeihiService/Create"
	DTakoUriageKeihiService_Get_FullMethodName    = "/ryohi.DTakoUriageKeihiService/Get"
	DTakoUriageKeihiService_Update_FullMethodName = "/ryohi.DTakoUriageKeihiService/Update"
	DTakoUriageKeihiService_Delete_FullMethodName = "/ryohi.DTakoUriageKeihiService/Delete"
	DTakoUriageKeihiService_List_FullMethodName   = "/ryohi.DTakoUriageKeihiService/List"
)

// DTakoUriageKeihiServiceClient is the client API for DTakoUriageKeihiService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// DTakoUriageKeihiサービス - 経費精算データ管理
type DTakoUriageKeihiServiceClient interface {
	// 経費精算データ作成
	Create(ctx context.Context, in *CreateDTakoUriageKeihiRequest, opts ...grpc.CallOption) (*DTakoUriageKeihiResponse, error)
	// 経費精算データ取得
	Get(ctx context.Context, in *GetDTakoUriageKeihiRequest, opts ...grpc.CallOption) (*DTakoUriageKeihiResponse, error)
	// 経費精算データ更新
	Update(ctx context.Context, in *UpdateDTakoUriageKeihiRequest, opts ...grpc.CallOption) (*DTakoUriageKeihiResponse, error)
	// 経費精算データ削除
	Delete(ctx context.Context, in *DeleteDTakoUriageKeihiRequest, opts ...grpc.CallOption) (*Empty, error)
	// 経費精算データ一覧取得
	List(ctx context.Context, in *ListDTakoUriageKeihiRequest, opts ...grpc.CallOption) (*ListDTakoUriageKeihiResponse, error)
}

type dTakoUriageKeihiServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewDTakoUriageKeihiServiceClient(cc grpc.ClientConnInterface) DTakoUriageKeihiServiceClient {
	return &dTakoUriageKeihiServiceClient{cc}
}

func (c *dTakoUriageKeihiServiceClient) Create(ctx context.Context, in *CreateDTakoUriageKeihiRequest, opts ...grpc.CallOption) (*DTakoUriageKeihiResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DTakoUriageKeihiResponse)
	err := c.cc.Invoke(ctx, DTakoUriageKeihiService_Create_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dTakoUriageKeihiServiceClient) Get(ctx context.Context, in *GetDTakoUriageKeihiRequest, opts ...grpc.CallOption) (*DTakoUriageKeihiResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DTakoUriageKeihiResponse)
	err := c.cc.Invoke(ctx, DTakoUriageKeihiService_Get_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dTakoUriageKeihiServiceClient) Update(ctx context.Context, in *UpdateDTakoUriageKeihiRequest, opts ...grpc.CallOption) (*DTakoUriageKeihiResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DTakoUriageKeihiResponse)
	err := c.cc.Invoke(ctx, DTakoUriageKeihiService_Update_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dTakoUriageKeihiServiceClient) Delete(ctx context.Context, in *DeleteDTakoUriageKeihiRequest, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, DTakoUriageKeihiService_Delete_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dTakoUriageKeihiServiceClient) List(ctx context.Context, in *ListDTakoUriageKeihiRequest, opts ...grpc.CallOption) (*ListDTakoUriageKeihiResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListDTakoUriageKeihiResponse)
	err := c.cc.Invoke(ctx, DTakoUriageKeihiService_List_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// DTakoUriageKeihiServiceServer is the server API for DTakoUriageKeihiService service.
// All implementations should embed UnimplementedDTakoUriageKeihiServiceServer
// for forward compatibility.
//
// DTakoUriageKeihiサービス - 経費精算データ管理
type DTakoUriageKeihiServiceServer interface {
	// 経費精算データ作成
	Create(context.Context, *CreateDTakoUriageKeihiRequest) (*DTakoUriageKeihiResponse, error)
	// 経費精算データ取得
	Get(context.Context, *GetDTakoUriageKeihiRequest) (*DTakoUriageKeihiResponse, error)
	// 経費精算データ更新
	Update(context.Context, *UpdateDTakoUriageKeihiRequest) (*DTakoUriageKeihiResponse, error)
	// 経費精算データ削除
	Delete(context.Context, *DeleteDTakoUriageKeihiRequest) (*Empty, error)
	// 経費精算データ一覧取得
	List(context.Context, *ListDTakoUriageKeihiRequest) (*ListDTakoUriageKeihiResponse, error)
}

// UnimplementedDTakoUriageKeihiServiceServer should be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedDTakoUriageKeihiServiceServer struct{}

func (UnimplementedDTakoUriageKeihiServiceServer) Create(context.Context, *CreateDTakoUriageKeihiRequest) (*DTakoUriageKeihiResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Create not implemented")
}
func (UnimplementedDTakoUriageKeihiServiceServer) Get(context.Context, *GetDTakoUriageKeihiRequest) (*DTakoUriageKeihiResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedDTakoUriageKeihiServiceServer) Update(context.Context, *UpdateDTakoUriageKeihiRequest) (*DTakoUriageKeihiResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Update not implemented")
}
func (UnimplementedDTakoUriageKeihiServiceServer) Delete(context.Context, *DeleteDTakoUriageKeihiRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedDTakoUriageKeihiServiceServer) List(context.Context, *ListDTakoUriageKeihiRequest) (*ListDTakoUriageKeihiResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method List not implemented")
}
func (UnimplementedDTakoUriageKeihiServiceServer) testEmbeddedByValue() {}

// UnsafeDTakoUriageKeihiServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to DTakoUriageKeihiServiceServer will
// result in compilation errors.
type UnsafeDTakoUriageKeihiServiceServer interface {
	mustEmbedUnimplementedDTakoUriageKeihiServiceServer()
}

func RegisterDTakoUriageKeihiServiceServer(s grpc.ServiceRegistrar, srv DTakoUriageKeihiServiceServer) {
	// If the following call pancis, it indicates UnimplementedDTakoUriageKeihiServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&DTakoUriageKeihiService_ServiceDesc, srv)
}

func _DTakoUriageKeihiService_Create_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateDTakoUriageKeihiRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DTakoUriageKeihiServiceServer).Create(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DTakoUriageKeihiService_Create_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DTakoUriageKeihiServiceServer).Create(ctx, req.(*CreateDTakoUriageKeihiRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DTakoUriageKeihiService_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetDTakoUriageKeihiRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DTakoUriageKeihiServiceServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DTakoUriageKeihiService_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DTakoUriageKeihiServiceServer).Get(ctx, req.(*GetDTakoUriageKeihiRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DTakoUriageKeihiService_Update_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateDTakoUriageKeihiRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DTakoUriageKeihiServiceServer).Update(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DTakoUriageKeihiService_Update_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DTakoUriageKeihiServiceServer).Update(ctx, req.(*UpdateDTakoUriageKeihiRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DTakoUriageKeihiService_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteDTakoUriageKeihiRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DTakoUriageKeihiServiceServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DTakoUriageKeihiService_Delete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DTakoUriageKeihiServiceServer).Delete(ctx, req.(*DeleteDTakoUriageKeihiRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DTakoUriageKeihiService_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListDTakoUriageKeihiRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DTakoUriageKeihiServiceServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DTakoUriageKeihiService_List_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DTakoUriageKeihiServiceServer).List(ctx, req.(*ListDTakoUriageKeihiRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// DTakoUriageKeihiService_ServiceDesc is the grpc.ServiceDesc for DTakoUriageKeihiService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var DTakoUriageKeihiService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "ryohi.DTakoUriageKeihiService",
	HandlerType: (*DTakoUriageKeihiServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Create",
			Handler:    _DTakoUriageKeihiService_Create_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _DTakoUriageKeihiService_Get_Handler,
		},
		{
			MethodName: "Update",
			Handler:    _DTakoUriageKeihiService_Update_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _DTakoUriageKeihiService_Delete_Handler,
		},
		{
			MethodName: "List",
			Handler:    _DTakoUriageKeihiService_List_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "ryohi.proto",
}

const (
	ETCMeisaiService_Create_FullMethodName = "/ryohi.ETCMeisaiService/Create"
	ETCMeisaiService_Get_FullMethodName    = "/ryohi.ETCMeisaiService/Get"
	ETCMeisaiService_Update_FullMethodName = "/ryohi.ETCMeisaiService/Update"
	ETCMeisaiService_Delete_FullMethodName = "/ryohi.ETCMeisaiService/Delete"
	ETCMeisaiService_List_FullMethodName   = "/ryohi.ETCMeisaiService/List"
)

// ETCMeisaiServiceClient is the client API for ETCMeisaiService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// ETCMeisaiサービス - ETC明細データ管理
type ETCMeisaiServiceClient interface {
	// ETC明細データ作成
	Create(ctx context.Context, in *CreateETCMeisaiRequest, opts ...grpc.CallOption) (*ETCMeisaiResponse, error)
	// ETC明細データ取得
	Get(ctx context.Context, in *GetETCMeisaiRequest, opts ...grpc.CallOption) (*ETCMeisaiResponse, error)
	// ETC明細データ更新
	Update(ctx context.Context, in *UpdateETCMeisaiRequest, opts ...grpc.CallOption) (*ETCMeisaiResponse, error)
	// ETC明細データ削除
	Delete(ctx context.Context, in *DeleteETCMeisaiRequest, opts ...grpc.CallOption) (*Empty, error)
	// ETC明細データ一覧取得
	List(ctx context.Context, in *ListETCMeisaiRequest, opts ...grpc.CallOption) (*ListETCMeisaiResponse, error)
}

type eTCMeisaiServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewETCMeisaiServiceClient(cc grpc.ClientConnInterface) ETCMeisaiServiceClient {
	return &eTCMeisaiServiceClient{cc}
}

func (c *eTCMeisaiServiceClient) Create(ctx context.Context, in *CreateETCMeisaiRequest, opts ...grpc.CallOption) (*ETCMeisaiResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ETCMeisaiResponse)
	err := c.cc.Invoke(ctx, ETCMeisaiService_Create_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eTCMeisaiServiceClient) Get(ctx context.Context, in *GetETCMeisaiRequest, opts ...grpc.CallOption) (*ETCMeisaiResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ETCMeisaiResponse)
	err := c.cc.Invoke(ctx, ETCMeisaiService_Get_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eTCMeisaiServiceClient) Update(ctx context.Context, in *UpdateETCMeisaiRequest, opts ...grpc.CallOption) (*ETCMeisaiResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ETCMeisaiResponse)
	err := c.cc.Invoke(ctx, ETCMeisaiService_Update_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eTCMeisaiServiceClient) Delete(ctx context.Context, in *DeleteETCMeisaiRequest, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, ETCMeisaiService_Delete_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eTCMeisaiServiceClient) List(ctx context.Context, in *ListETCMeisaiRequest, opts ...grpc.CallOption) (*ListETCMeisaiResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListETCMeisaiResponse)
	err := c.cc.Invoke(ctx, ETCMeisaiService_List_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ETCMeisaiServiceServer is the server API for ETCMeisaiService service.
// All implementations should embed UnimplementedETCMeisaiServiceServer
// for forward compatibility.
//
// ETCMeisaiサービス - ETC明細データ管理
type ETCMeisaiServiceServer interface {
	// ETC明細データ作成
	Create(context.Context, *CreateETCMeisaiRequest) (*ETCMeisaiResponse, error)
	// ETC明細データ取得
	Get(context.Context, *GetETCMeisaiRequest) (*ETCMeisaiResponse, error)
	// ETC明細データ更新
	Update(context.Context, *UpdateETCMeisaiRequest) (*ETCMeisaiResponse, error)
	// ETC明細データ削除
	Delete(context.Context, *DeleteETCMeisaiRequest) (*Empty, error)
	// ETC明細データ一覧取得
	List(context.Context, *ListETCMeisaiRequest) (*ListETCMeisaiResponse, error)
}

// UnimplementedETCMeisaiServiceServer should be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedETCMeisaiServiceServer struct{}

func (UnimplementedETCMeisaiServiceServer) Create(context.Context, *CreateETCMeisaiRequest) (*ETCMeisaiResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Create not implemented")
}
func (UnimplementedETCMeisaiServiceServer) Get(context.Context, *GetETCMeisaiRequest) (*ETCMeisaiResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedETCMeisaiServiceServer) Update(context.Context, *UpdateETCMeisaiRequest) (*ETCMeisaiResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Update not implemented")
}
func (UnimplementedETCMeisaiServiceServer) Delete(context.Context, *DeleteETCMeisaiRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedETCMeisaiServiceServer) List(context.Context, *ListETCMeisaiRequest) (*ListETCMeisaiResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method List not implemented")
}
func (UnimplementedETCMeisaiServiceServer) testEmbeddedByValue() {}

// UnsafeETCMeisaiServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ETCMeisaiServiceServer will
// result in compilation errors.
type UnsafeETCMeisaiServiceServer interface {
	mustEmbedUnimplementedETCMeisaiServiceServer()
}

func RegisterETCMeisaiServiceServer(s grpc.ServiceRegistrar, srv ETCMeisaiServiceServer) {
	// If the following call pancis, it indicates UnimplementedETCMeisaiServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&ETCMeisaiService_ServiceDesc, srv)
}

func _ETCMeisaiService_Create_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateETCMeisaiRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ETCMeisaiServiceServer).Create(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ETCMeisaiService_Create_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ETCMeisaiServiceServer).Create(ctx, req.(*CreateETCMeisaiRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ETCMeisaiService_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetETCMeisaiRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ETCMeisaiServiceServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ETCMeisaiService_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ETCMeisaiServiceServer).Get(ctx, req.(*GetETCMeisaiRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ETCMeisaiService_Update_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateETCMeisaiRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ETCMeisaiServiceServer).Update(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ETCMeisaiService_Update_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ETCMeisaiServiceServer).Update(ctx, req.(*UpdateETCMeisaiRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ETCMeisaiService_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteETCMeisaiRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ETCMeisaiServiceServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ETCMeisaiService_Delete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ETCMeisaiServiceServer).Delete(ctx, req.(*DeleteETCMeisaiRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ETCMeisaiService_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListETCMeisaiRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ETCMeisaiServiceServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ETCMeisaiService_List_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ETCMeisaiServiceServer).List(ctx, req.(*ListETCMeisaiRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ETCMeisaiService_ServiceDesc is the grpc.ServiceDesc for ETCMeisaiService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ETCMeisaiService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "ryohi.ETCMeisaiService",
	HandlerType: (*ETCMeisaiServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Create",
			Handler:    _ETCMeisaiService_Create_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _ETCMeisaiService_Get_Handler,
		},
		{
			MethodName: "Update",
			Handler:    _ETCMeisaiService_Update_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _ETCMeisaiService_Delete_Handler,
		},
		{
			MethodName: "List",
			Handler:    _ETCMeisaiService_List_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "ryohi.proto",
}

const (
	DTakoFerryRowsService_Create_FullMethodName = "/ryohi.DTakoFerryRowsService/Create"
	DTakoFerryRowsService_Get_FullMethodName    = "/ryohi.DTakoFerryRowsService/Get"
	DTakoFerryRowsService_Update_FullMethodName = "/ryohi.DTakoFerryRowsService/Update"
	DTakoFerryRowsService_Delete_FullMethodName = "/ryohi.DTakoFerryRowsService/Delete"
	DTakoFerryRowsService_List_FullMethodName   = "/ryohi.DTakoFerryRowsService/List"
)

// DTakoFerryRowsServiceClient is the client API for DTakoFerryRowsService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// DTakoFerryRowsサービス - フェリー運行データ管理
type DTakoFerryRowsServiceClient interface {
	// フェリー運行データ作成
	Create(ctx context.Context, in *CreateDTakoFerryRowsRequest, opts ...grpc.CallOption) (*DTakoFerryRowsResponse, error)
	// フェリー運行データ取得
	Get(ctx context.Context, in *GetDTakoFerryRowsRequest, opts ...grpc.CallOption) (*DTakoFerryRowsResponse, error)
	// フェリー運行データ更新
	Update(ctx context.Context, in *UpdateDTakoFerryRowsRequest, opts ...grpc.CallOption) (*DTakoFerryRowsResponse, error)
	// フェリー運行データ削除
	Delete(ctx context.Context, in *DeleteDTakoFerryRowsRequest, opts ...grpc.CallOption) (*Empty, error)
	// フェリー運行データ一覧取得
	List(ctx context.Context, in *ListDTakoFerryRowsRequest, opts ...grpc.CallOption) (*ListDTakoFerryRowsResponse, error)
}

type dTakoFerryRowsServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewDTakoFerryRowsServiceClient(cc grpc.ClientConnInterface) DTakoFerryRowsServiceClient {
	return &dTakoFerryRowsServiceClient{cc}
}

func (c *dTakoFerryRowsServiceClient) Create(ctx context.Context, in *CreateDTakoFerryRowsRequest, opts ...grpc.CallOption) (*DTakoFerryRowsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DTakoFerryRowsResponse)
	err := c.cc.Invoke(ctx, DTakoFerryRowsService_Create_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dTakoFerryRowsServiceClient) Get(ctx context.Context, in *GetDTakoFerryRowsRequest, opts ...grpc.CallOption) (*DTakoFerryRowsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DTakoFerryRowsResponse)
	err := c.cc.Invoke(ctx, DTakoFerryRowsService_Get_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dTakoFerryRowsServiceClient) Update(ctx context.Context, in *UpdateDTakoFerryRowsRequest, opts ...grpc.CallOption) (*DTakoFerryRowsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DTakoFerryRowsResponse)
	err := c.cc.Invoke(ctx, DTakoFerryRowsService_Update_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dTakoFerryRowsServiceClient) Delete(ctx context.Context, in *DeleteDTakoFerryRowsRequest, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, DTakoFerryRowsService_Delete_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dTakoFerryRowsServiceClient) List(ctx context.Context, in *ListDTakoFerryRowsRequest, opts ...grpc.CallOption) (*ListDTakoFerryRowsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListDTakoFerryRowsResponse)
	err := c.cc.Invoke(ctx, DTakoFerryRowsService_List_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// DTakoFerryRowsServiceServer is the server API for DTakoFerryRowsService service.
// All implementations should embed UnimplementedDTakoFerryRowsServiceServer
// for forward compatibility.
//
// DTakoFerryRowsサービス - フェリー運行データ管理
type DTakoFerryRowsServiceServer interface {
	// フェリー運行データ作成
	Create(context.Context, *CreateDTakoFerryRowsRequest) (*DTakoFerryRowsResponse, error)
	// フェリー運行データ取得
	Get(context.Context, *GetDTakoFerryRowsRequest) (*DTakoFerryRowsResponse, error)
	// フェリー運行データ更新
	Update(context.Context, *UpdateDTakoFerryRowsRequest) (*DTakoFerryRowsResponse, error)
	// フェリー運行データ削除
	Delete(context.Context, *DeleteDTakoFerryRowsRequest) (*Empty, error)
	// フェリー運行データ一覧取得
	List(context.Context, *ListDTakoFerryRowsRequest) (*ListDTakoFerryRowsResponse, error)
}

// UnimplementedDTakoFerryRowsServiceServer should be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedDTakoFerryRowsServiceServer struct{}

func (UnimplementedDTakoFerryRowsServiceServer) Create(context.Context, *CreateDTakoFerryRowsRequest) (*DTakoFerryRowsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Create not implemented")
}
func (UnimplementedDTakoFerryRowsServiceServer) Get(context.Context, *GetDTakoFerryRowsRequest) (*DTakoFerryRowsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedDTakoFerryRowsServiceServer) Update(context.Context, *UpdateDTakoFerryRowsRequest) (*DTakoFerryRowsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Update not implemented")
}
func (UnimplementedDTakoFerryRowsServiceServer) Delete(context.Context, *DeleteDTakoFerryRowsRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedDTakoFerryRowsServiceServer) List(context.Context, *ListDTakoFerryRowsRequest) (*ListDTakoFerryRowsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method List not implemented")
}
func (UnimplementedDTakoFerryRowsServiceServer) testEmbeddedByValue() {}

// UnsafeDTakoFerryRowsServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to DTakoFerryRowsServiceServer will
// result in compilation errors.
type UnsafeDTakoFerryRowsServiceServer interface {
	mustEmbedUnimplementedDTakoFerryRowsServiceServer()
}

func RegisterDTakoFerryRowsServiceServer(s grpc.ServiceRegistrar, srv DTakoFerryRowsServiceServer) {
	// If the following call pancis, it indicates UnimplementedDTakoFerryRowsServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&DTakoFerryRowsService_ServiceDesc, srv)
}

func _DTakoFerryRowsService_Create_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateDTakoFerryRowsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DTakoFerryRowsServiceServer).Create(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DTakoFerryRowsService_Create_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DTakoFerryRowsServiceServer).Create(ctx, req.(*CreateDTakoFerryRowsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DTakoFerryRowsService_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetDTakoFerryRowsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DTakoFerryRowsServiceServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DTakoFerryRowsService_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DTakoFerryRowsServiceServer).Get(ctx, req.(*GetDTakoFerryRowsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DTakoFerryRowsService_Update_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateDTakoFerryRowsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DTakoFerryRowsServiceServer).Update(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DTakoFerryRowsService_Update_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DTakoFerryRowsServiceServer).Update(ctx, req.(*UpdateDTakoFerryRowsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DTakoFerryRowsService_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteDTakoFerryRowsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DTakoFerryRowsServiceServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DTakoFerryRowsService_Delete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DTakoFerryRowsServiceServer).Delete(ctx, req.(*DeleteDTakoFerryRowsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DTakoFerryRowsService_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListDTakoFerryRowsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DTakoFerryRowsServiceServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DTakoFerryRowsService_List_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DTakoFerryRowsServiceServer).List(ctx, req.(*ListDTakoFerryRowsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// DTakoFerryRowsService_ServiceDesc is the grpc.ServiceDesc for DTakoFerryRowsService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var DTakoFerryRowsService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "ryohi.DTakoFerryRowsService",
	HandlerType: (*DTakoFerryRowsServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Create",
			Handler:    _DTakoFerryRowsService_Create_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _DTakoFerryRowsService_Get_Handler,
		},
		{
			MethodName: "Update",
			Handler:    _DTakoFerryRowsService_Update_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _DTakoFerryRowsService_Delete_Handler,
		},
		{
			MethodName: "List",
			Handler:    _DTakoFerryRowsService_List_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "ryohi.proto",
}

const (
	ETCMeisaiMappingService_Create_FullMethodName              = "/ryohi.ETCMeisaiMappingService/Create"
	ETCMeisaiMappingService_Get_FullMethodName                 = "/ryohi.ETCMeisaiMappingService/Get"
	ETCMeisaiMappingService_Update_FullMethodName              = "/ryohi.ETCMeisaiMappingService/Update"
	ETCMeisaiMappingService_Delete_FullMethodName              = "/ryohi.ETCMeisaiMappingService/Delete"
	ETCMeisaiMappingService_List_FullMethodName                = "/ryohi.ETCMeisaiMappingService/List"
	ETCMeisaiMappingService_GetDTakoRowIDByHash_FullMethodName = "/ryohi.ETCMeisaiMappingService/GetDTakoRowIDByHash"
)

// ETCMeisaiMappingServiceClient is the client API for ETCMeisaiMappingService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// ETCMeisaiMappingサービス - ETC明細とDTakoRowsのマッピング管理
type ETCMeisaiMappingServiceClient interface {
	// マッピング作成
	Create(ctx context.Context, in *CreateETCMeisaiMappingRequest, opts ...grpc.CallOption) (*ETCMeisaiMappingResponse, error)
	// マッピング取得
	Get(ctx context.Context, in *GetETCMeisaiMappingRequest, opts ...grpc.CallOption) (*ETCMeisaiMappingResponse, error)
	// マッピング更新
	Update(ctx context.Context, in *UpdateETCMeisaiMappingRequest, opts ...grpc.CallOption) (*ETCMeisaiMappingResponse, error)
	// マッピング削除
	Delete(ctx context.Context, in *DeleteETCMeisaiMappingRequest, opts ...grpc.CallOption) (*Empty, error)
	// マッピング一覧取得
	List(ctx context.Context, in *ListETCMeisaiMappingRequest, opts ...grpc.CallOption) (*ListETCMeisaiMappingResponse, error)
	// ハッシュからDTakoRowIDを取得
	GetDTakoRowIDByHash(ctx context.Context, in *GetDTakoRowIDByHashRequest, opts ...grpc.CallOption) (*GetDTakoRowIDByHashResponse, error)
}

type eTCMeisaiMappingServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewETCMeisaiMappingServiceClient(cc grpc.ClientConnInterface) ETCMeisaiMappingServiceClient {
	return &eTCMeisaiMappingServiceClient{cc}
}

func (c *eTCMeisaiMappingServiceClient) Create(ctx context.Context, in *CreateETCMeisaiMappingRequest, opts ...grpc.CallOption) (*ETCMeisaiMappingResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ETCMeisaiMappingResponse)
	err := c.cc.Invoke(ctx, ETCMeisaiMappingService_Create_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eTCMeisaiMappingServiceClient) Get(ctx context.Context, in *GetETCMeisaiMappingRequest, opts ...grpc.CallOption) (*ETCMeisaiMappingResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ETCMeisaiMappingResponse)
	err := c.cc.Invoke(ctx, ETCMeisaiMappingService_Get_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eTCMeisaiMappingServiceClient) Update(ctx context.Context, in *UpdateETCMeisaiMappingRequest, opts ...grpc.CallOption) (*ETCMeisaiMappingResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ETCMeisaiMappingResponse)
	err := c.cc.Invoke(ctx, ETCMeisaiMappingService_Update_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eTCMeisaiMappingServiceClient) Delete(ctx context.Context, in *DeleteETCMeisaiMappingRequest, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, ETCMeisaiMappingService_Delete_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eTCMeisaiMappingServiceClient) List(ctx context.Context, in *ListETCMeisaiMappingRequest, opts ...grpc.CallOption) (*ListETCMeisaiMappingResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListETCMeisaiMappingResponse)
	err := c.cc.Invoke(ctx, ETCMeisaiMappingService_List_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eTCMeisaiMappingServiceClient) GetDTakoRowIDByHash(ctx context.Context, in *GetDTakoRowIDByHashRequest, opts ...grpc.CallOption) (*GetDTakoRowIDByHashResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetDTakoRowIDByHashResponse)
	err := c.cc.Invoke(ctx, ETCMeisaiMappingService_GetDTakoRowIDByHash_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ETCMeisaiMappingServiceServer is the server API for ETCMeisaiMappingService service.
// All implementations should embed UnimplementedETCMeisaiMappingServiceServer
// for forward compatibility.
//
// ETCMeisaiMappingサービス - ETC明細とDTakoRowsのマッピング管理
type ETCMeisaiMappingServiceServer interface {
	// マッピング作成
	Create(context.Context, *CreateETCMeisaiMappingRequest) (*ETCMeisaiMappingResponse, error)
	// マッピング取得
	Get(context.Context, *GetETCMeisaiMappingRequest) (*ETCMeisaiMappingResponse, error)
	// マッピング更新
	Update(context.Context, *UpdateETCMeisaiMappingRequest) (*ETCMeisaiMappingResponse, error)
	// マッピング削除
	Delete(context.Context, *DeleteETCMeisaiMappingRequest) (*Empty, error)
	// マッピング一覧取得
	List(context.Context, *ListETCMeisaiMappingRequest) (*ListETCMeisaiMappingResponse, error)
	// ハッシュからDTakoRowIDを取得
	GetDTakoRowIDByHash(context.Context, *GetDTakoRowIDByHashRequest) (*GetDTakoRowIDByHashResponse, error)
}

// UnimplementedETCMeisaiMappingServiceServer should be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedETCMeisaiMappingServiceServer struct{}

func (UnimplementedETCMeisaiMappingServiceServer) Create(context.Context, *CreateETCMeisaiMappingRequest) (*ETCMeisaiMappingResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Create not implemented")
}
func (UnimplementedETCMeisaiMappingServiceServer) Get(context.Context, *GetETCMeisaiMappingRequest) (*ETCMeisaiMappingResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedETCMeisaiMappingServiceServer) Update(context.Context, *UpdateETCMeisaiMappingRequest) (*ETCMeisaiMappingResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Update not implemented")
}
func (UnimplementedETCMeisaiMappingServiceServer) Delete(context.Context, *DeleteETCMeisaiMappingRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedETCMeisaiMappingServiceServer) List(context.Context, *ListETCMeisaiMappingRequest) (*ListETCMeisaiMappingResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method List not implemented")
}
func (UnimplementedETCMeisaiMappingServiceServer) GetDTakoRowIDByHash(context.Context, *GetDTakoRowIDByHashRequest) (*GetDTakoRowIDByHashResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetDTakoRowIDByHash not implemented")
}
func (UnimplementedETCMeisaiMappingServiceServer) testEmbeddedByValue() {}

// UnsafeETCMeisaiMappingServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ETCMeisaiMappingServiceServer will
// result in compilation errors.
type UnsafeETCMeisaiMappingServiceServer interface {
	mustEmbedUnimplementedETCMeisaiMappingServiceServer()
}

func RegisterETCMeisaiMappingServiceServer(s grpc.ServiceRegistrar, srv ETCMeisaiMappingServiceServer) {
	// If the following call pancis, it indicates UnimplementedETCMeisaiMappingServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&ETCMeisaiMappingService_ServiceDesc, srv)
}

func _ETCMeisaiMappingService_Create_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateETCMeisaiMappingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ETCMeisaiMappingServiceServer).Create(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ETCMeisaiMappingService_Create_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ETCMeisaiMappingServiceServer).Create(ctx, req.(*CreateETCMeisaiMappingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ETCMeisaiMappingService_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetETCMeisaiMappingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ETCMeisaiMappingServiceServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ETCMeisaiMappingService_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ETCMeisaiMappingServiceServer).Get(ctx, req.(*GetETCMeisaiMappingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ETCMeisaiMappingService_Update_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateETCMeisaiMappingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ETCMeisaiMappingServiceServer).Update(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ETCMeisaiMappingService_Update_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ETCMeisaiMappingServiceServer).Update(ctx, req.(*UpdateETCMeisaiMappingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ETCMeisaiMappingService_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteETCMeisaiMappingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ETCMeisaiMappingServiceServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ETCMeisaiMappingService_Delete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ETCMeisaiMappingServiceServer).Delete(ctx, req.(*DeleteETCMeisaiMappingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ETCMeisaiMappingService_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListETCMeisaiMappingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ETCMeisaiMappingServiceServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ETCMeisaiMappingService_List_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ETCMeisaiMappingServiceServer).List(ctx, req.(*ListETCMeisaiMappingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ETCMeisaiMappingService_GetDTakoRowIDByHash_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetDTakoRowIDByHashRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ETCMeisaiMappingServiceServer).GetDTakoRowIDByHash(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ETCMeisaiMappingService_GetDTakoRowIDByHash_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ETCMeisaiMappingServiceServer).GetDTakoRowIDByHash(ctx, req.(*GetDTakoRowIDByHashRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ETCMeisaiMappingService_ServiceDesc is the grpc.ServiceDesc for ETCMeisaiMappingService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ETCMeisaiMappingService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "ryohi.ETCMeisaiMappingService",
	HandlerType: (*ETCMeisaiMappingServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Create",
			Handler:    _ETCMeisaiMappingService_Create_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _ETCMeisaiMappingService_Get_Handler,
		},
		{
			MethodName: "Update",
			Handler:    _ETCMeisaiMappingService_Update_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _ETCMeisaiMappingService_Delete_Handler,
		},
		{
			MethodName: "List",
			Handler:    _ETCMeisaiMappingService_List_Handler,
		},
		{
			MethodName: "GetDTakoRowIDByHash",
			Handler:    _ETCMeisaiMappingService_GetDTakoRowIDByHash_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "ryohi.proto",
}

const (
	DTakoCarsService_Get_FullMethodName          = "/ryohi.DTakoCarsService/Get"
	DTakoCarsService_List_FullMethodName         = "/ryohi.DTakoCarsService/List"
	DTakoCarsService_GetByCarCode_FullMethodName = "/ryohi.DTakoCarsService/GetByCarCode"
)

// DTakoCarsServiceClient is the client API for DTakoCarsService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// DTakoCarsサービス - 車輌マスタ管理（本番DB、読み取り専用）
type DTakoCarsServiceClient interface {
	// 車輌情報取得
	Get(ctx context.Context, in *GetDTakoCarsRequest, opts ...grpc.CallOption) (*DTakoCarsResponse, error)
	// 車輌情報一覧取得
	List(ctx context.Context, in *ListDTakoCarsRequest, opts ...grpc.CallOption) (*ListDTakoCarsResponse, error)
	// 車輌CDで車輌情報取得
	GetByCarCode(ctx context.Context, in *GetDTakoCarsByCarCodeRequest, opts ...grpc.CallOption) (*DTakoCarsResponse, error)
}

type dTakoCarsServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewDTakoCarsServiceClient(cc grpc.ClientConnInterface) DTakoCarsServiceClient {
	return &dTakoCarsServiceClient{cc}
}

func (c *dTakoCarsServiceClient) Get(ctx context.Context, in *GetDTakoCarsRequest, opts ...grpc.CallOption) (*DTakoCarsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DTakoCarsResponse)
	err := c.cc.Invoke(ctx, DTakoCarsService_Get_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dTakoCarsServiceClient) List(ctx context.Context, in *ListDTakoCarsRequest, opts ...grpc.CallOption) (*ListDTakoCarsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListDTakoCarsResponse)
	err := c.cc.Invoke(ctx, DTakoCarsService_List_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dTakoCarsServiceClient) GetByCarCode(ctx context.Context, in *GetDTakoCarsByCarCodeRequest, opts ...grpc.CallOption) (*DTakoCarsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DTakoCarsResponse)
	err := c.cc.Invoke(ctx, DTakoCarsService_GetByCarCode_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// DTakoCarsServiceServer is the server API for DTakoCarsService service.
// All implementations should embed UnimplementedDTakoCarsServiceServer
// for forward compatibility.
//
// DTakoCarsサービス - 車輌マスタ管理（本番DB、読み取り専用）
type DTakoCarsServiceServer interface {
	// 車輌情報取得
	Get(context.Context, *GetDTakoCarsRequest) (*DTakoCarsResponse, error)
	// 車輌情報一覧取得
	List(context.Context, *ListDTakoCarsRequest) (*ListDTakoCarsResponse, error)
	// 車輌CDで車輌情報取得
	GetByCarCode(context.Context, *GetDTakoCarsByCarCodeRequest) (*DTakoCarsResponse, error)
}

// UnimplementedDTakoCarsServiceServer should be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedDTakoCarsServiceServer struct{}

func (UnimplementedDTakoCarsServiceServer) Get(context.Context, *GetDTakoCarsRequest) (*DTakoCarsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedDTakoCarsServiceServer) List(context.Context, *ListDTakoCarsRequest) (*ListDTakoCarsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method List not implemented")
}
func (UnimplementedDTakoCarsServiceServer) GetByCarCode(context.Context, *GetDTakoCarsByCarCodeRequest) (*DTakoCarsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetByCarCode not implemented")
}
func (UnimplementedDTakoCarsServiceServer) testEmbeddedByValue() {}

// UnsafeDTakoCarsServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to DTakoCarsServiceServer will
// result in compilation errors.
type UnsafeDTakoCarsServiceServer interface {
	mustEmbedUnimplementedDTakoCarsServiceServer()
}

func RegisterDTakoCarsServiceServer(s grpc.ServiceRegistrar, srv DTakoCarsServiceServer) {
	// If the following call pancis, it indicates UnimplementedDTakoCarsServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&DTakoCarsService_ServiceDesc, srv)
}

func _DTakoCarsService_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetDTakoCarsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DTakoCarsServiceServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DTakoCarsService_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DTakoCarsServiceServer).Get(ctx, req.(*GetDTakoCarsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DTakoCarsService_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListDTakoCarsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DTakoCarsServiceServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DTakoCarsService_List_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DTakoCarsServiceServer).List(ctx, req.(*ListDTakoCarsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DTakoCarsService_GetByCarCode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetDTakoCarsByCarCodeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DTakoCarsServiceServer).GetByCarCode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DTakoCarsService_GetByCarCode_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DTakoCarsServiceServer).GetByCarCode(ctx, req.(*GetDTakoCarsByCarCodeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// DTakoCarsService_ServiceDesc is the grpc.ServiceDesc for DTakoCarsService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var DTakoCarsService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "ryohi.DTakoCarsService",
	HandlerType: (*DTakoCarsServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Get",
			Handler:    _DTakoCarsService_Get_Handler,
		},
		{
			MethodName: "List",
			Handler:    _DTakoCarsService_List_Handler,
		},
		{
			MethodName: "GetByCarCode",
			Handler:    _DTakoCarsService_GetByCarCode_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "ryohi.proto",
}

const (
	DTakoEventsService_Get_FullMethodName              = "/ryohi.DTakoEventsService/Get"
	DTakoEventsService_List_FullMethodName             = "/ryohi.DTakoEventsService/List"
	DTakoEventsService_GetByOperationNo_FullMethodName = "/ryohi.DTakoEventsService/GetByOperationNo"
)

// DTakoEventsServiceClient is the client API for DTakoEventsService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// DTakoEventsサービス - イベント情報管理（本番DB、読み取り専用）
type DTakoEventsServiceClient interface {
	// イベント情報取得
	Get(ctx context.Context, in *GetDTakoEventsRequest, opts ...grpc.CallOption) (*DTakoEventsResponse, error)
	// イベント情報一覧取得
	List(ctx context.Context, in *ListDTakoEventsRequest, opts ...grpc.CallOption) (*ListDTakoEventsResponse, error)
	// 運行NOでイベント情報取得
	GetByOperationNo(ctx context.Context, in *GetDTakoEventsByOperationNoRequest, opts ...grpc.CallOption) (*ListDTakoEventsResponse, error)
}

type dTakoEventsServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewDTakoEventsServiceClient(cc grpc.ClientConnInterface) DTakoEventsServiceClient {
	return &dTakoEventsServiceClient{cc}
}

func (c *dTakoEventsServiceClient) Get(ctx context.Context, in *GetDTakoEventsRequest, opts ...grpc.CallOption) (*DTakoEventsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DTakoEventsResponse)
	err := c.cc.Invoke(ctx, DTakoEventsService_Get_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dTakoEventsServiceClient) List(ctx context.Context, in *ListDTakoEventsRequest, opts ...grpc.CallOption) (*ListDTakoEventsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListDTakoEventsResponse)
	err := c.cc.Invoke(ctx, DTakoEventsService_List_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dTakoEventsServiceClient) GetByOperationNo(ctx context.Context, in *GetDTakoEventsByOperationNoRequest, opts ...grpc.CallOption) (*ListDTakoEventsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListDTakoEventsResponse)
	err := c.cc.Invoke(ctx, DTakoEventsService_GetByOperationNo_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// DTakoEventsServiceServer is the server API for DTakoEventsService service.
// All implementations should embed UnimplementedDTakoEventsServiceServer
// for forward compatibility.
//
// DTakoEventsサービス - イベント情報管理（本番DB、読み取り専用）
type DTakoEventsServiceServer interface {
	// イベント情報取得
	Get(context.Context, *GetDTakoEventsRequest) (*DTakoEventsResponse, error)
	// イベント情報一覧取得
	List(context.Context, *ListDTakoEventsRequest) (*ListDTakoEventsResponse, error)
	// 運行NOでイベント情報取得
	GetByOperationNo(context.Context, *GetDTakoEventsByOperationNoRequest) (*ListDTakoEventsResponse, error)
}

// UnimplementedDTakoEventsServiceServer should be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedDTakoEventsServiceServer struct{}

func (UnimplementedDTakoEventsServiceServer) Get(context.Context, *GetDTakoEventsRequest) (*DTakoEventsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedDTakoEventsServiceServer) List(context.Context, *ListDTakoEventsRequest) (*ListDTakoEventsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method List not implemented")
}
func (UnimplementedDTakoEventsServiceServer) GetByOperationNo(context.Context, *GetDTakoEventsByOperationNoRequest) (*ListDTakoEventsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetByOperationNo not implemented")
}
func (UnimplementedDTakoEventsServiceServer) testEmbeddedByValue() {}

// UnsafeDTakoEventsServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to DTakoEventsServiceServer will
// result in compilation errors.
type UnsafeDTakoEventsServiceServer interface {
	mustEmbedUnimplementedDTakoEventsServiceServer()
}

func RegisterDTakoEventsServiceServer(s grpc.ServiceRegistrar, srv DTakoEventsServiceServer) {
	// If the following call pancis, it indicates UnimplementedDTakoEventsServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&DTakoEventsService_ServiceDesc, srv)
}

func _DTakoEventsService_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetDTakoEventsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DTakoEventsServiceServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DTakoEventsService_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DTakoEventsServiceServer).Get(ctx, req.(*GetDTakoEventsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DTakoEventsService_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListDTakoEventsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DTakoEventsServiceServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DTakoEventsService_List_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DTakoEventsServiceServer).List(ctx, req.(*ListDTakoEventsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DTakoEventsService_GetByOperationNo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetDTakoEventsByOperationNoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DTakoEventsServiceServer).GetByOperationNo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DTakoEventsService_GetByOperationNo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DTakoEventsServiceServer).GetByOperationNo(ctx, req.(*GetDTakoEventsByOperationNoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// DTakoEventsService_ServiceDesc is the grpc.ServiceDesc for DTakoEventsService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var DTakoEventsService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "ryohi.DTakoEventsService",
	HandlerType: (*DTakoEventsServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Get",
			Handler:    _DTakoEventsService_Get_Handler,
		},
		{
			MethodName: "List",
			Handler:    _DTakoEventsService_List_Handler,
		},
		{
			MethodName: "GetByOperationNo",
			Handler:    _DTakoEventsService_GetByOperationNo_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "ryohi.proto",
}

const (
	DTakoRowsService_Get_FullMethodName              = "/ryohi.DTakoRowsService/Get"
	DTakoRowsService_List_FullMethodName             = "/ryohi.DTakoRowsService/List"
	DTakoRowsService_GetByOperationNo_FullMethodName = "/ryohi.DTakoRowsService/GetByOperationNo"
)

// DTakoRowsServiceClient is the client API for DTakoRowsService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// DTakoRowsサービス - 運行データ管理（本番DB、読み取り専用）
type DTakoRowsServiceClient interface {
	// 運行データ取得
	Get(ctx context.Context, in *GetDTakoRowsRequest, opts ...grpc.CallOption) (*DTakoRowsResponse, error)
	// 運行データ一覧取得
	List(ctx context.Context, in *ListDTakoRowsRequest, opts ...grpc.CallOption) (*ListDTakoRowsResponse, error)
	// 運行NOで運行データ取得
	GetByOperationNo(ctx context.Context, in *GetDTakoRowsByOperationNoRequest, opts ...grpc.CallOption) (*ListDTakoRowsResponse, error)
}

type dTakoRowsServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewDTakoRowsServiceClient(cc grpc.ClientConnInterface) DTakoRowsServiceClient {
	return &dTakoRowsServiceClient{cc}
}

func (c *dTakoRowsServiceClient) Get(ctx context.Context, in *GetDTakoRowsRequest, opts ...grpc.CallOption) (*DTakoRowsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DTakoRowsResponse)
	err := c.cc.Invoke(ctx, DTakoRowsService_Get_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dTakoRowsServiceClient) List(ctx context.Context, in *ListDTakoRowsRequest, opts ...grpc.CallOption) (*ListDTakoRowsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListDTakoRowsResponse)
	err := c.cc.Invoke(ctx, DTakoRowsService_List_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dTakoRowsServiceClient) GetByOperationNo(ctx context.Context, in *GetDTakoRowsByOperationNoRequest, opts ...grpc.CallOption) (*ListDTakoRowsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListDTakoRowsResponse)
	err := c.cc.Invoke(ctx, DTakoRowsService_GetByOperationNo_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// DTakoRowsServiceServer is the server API for DTakoRowsService service.
// All implementations should embed UnimplementedDTakoRowsServiceServer
// for forward compatibility.
//
// DTakoRowsサービス - 運行データ管理（本番DB、読み取り専用）
type DTakoRowsServiceServer interface {
	// 運行データ取得
	Get(context.Context, *GetDTakoRowsRequest) (*DTakoRowsResponse, error)
	// 運行データ一覧取得
	List(context.Context, *ListDTakoRowsRequest) (*ListDTakoRowsResponse, error)
	// 運行NOで運行データ取得
	GetByOperationNo(context.Context, *GetDTakoRowsByOperationNoRequest) (*ListDTakoRowsResponse, error)
}

// UnimplementedDTakoRowsServiceServer should be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedDTakoRowsServiceServer struct{}

func (UnimplementedDTakoRowsServiceServer) Get(context.Context, *GetDTakoRowsRequest) (*DTakoRowsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedDTakoRowsServiceServer) List(context.Context, *ListDTakoRowsRequest) (*ListDTakoRowsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method List not implemented")
}
func (UnimplementedDTakoRowsServiceServer) GetByOperationNo(context.Context, *GetDTakoRowsByOperationNoRequest) (*ListDTakoRowsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetByOperationNo not implemented")
}
func (UnimplementedDTakoRowsServiceServer) testEmbeddedByValue() {}

// UnsafeDTakoRowsServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to DTakoRowsServiceServer will
// result in compilation errors.
type UnsafeDTakoRowsServiceServer interface {
	mustEmbedUnimplementedDTakoRowsServiceServer()
}

func RegisterDTakoRowsServiceServer(s grpc.ServiceRegistrar, srv DTakoRowsServiceServer) {
	// If the following call pancis, it indicates UnimplementedDTakoRowsServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&DTakoRowsService_ServiceDesc, srv)
}

func _DTakoRowsService_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetDTakoRowsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DTakoRowsServiceServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DTakoRowsService_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DTakoRowsServiceServer).Get(ctx, req.(*GetDTakoRowsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DTakoRowsService_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListDTakoRowsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DTakoRowsServiceServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DTakoRowsService_List_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DTakoRowsServiceServer).List(ctx, req.(*ListDTakoRowsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DTakoRowsService_GetByOperationNo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetDTakoRowsByOperationNoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DTakoRowsServiceServer).GetByOperationNo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DTakoRowsService_GetByOperationNo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DTakoRowsServiceServer).GetByOperationNo(ctx, req.(*GetDTakoRowsByOperationNoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// DTakoRowsService_ServiceDesc is the grpc.ServiceDesc for DTakoRowsService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var DTakoRowsService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "ryohi.DTakoRowsService",
	HandlerType: (*DTakoRowsServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Get",
			Handler:    _DTakoRowsService_Get_Handler,
		},
		{
			MethodName: "List",
			Handler:    _DTakoRowsService_List_Handler,
		},
		{
			MethodName: "GetByOperationNo",
			Handler:    _DTakoRowsService_GetByOperationNo_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "ryohi.proto",
}

const (
	ETCNumService_List_FullMethodName            = "/ryohi.ETCNumService/List"
	ETCNumService_GetByETCCardNum_FullMethodName = "/ryohi.ETCNumService/GetByETCCardNum"
	ETCNumService_GetByCarID_FullMethodName      = "/ryohi.ETCNumService/GetByCarID"
)

// ETCNumServiceClient is the client API for ETCNumService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// ETCNumサービス - ETCカード番号マスタ管理（本番DB、読み取り専用）
type ETCNumServiceClient interface {
	// ETCカード番号一覧取得
	List(ctx context.Context, in *ListETCNumRequest, opts ...grpc.CallOption) (*ListETCNumResponse, error)
	// ETCカード番号で取得
	GetByETCCardNum(ctx context.Context, in *GetETCNumByETCCardNumRequest, opts ...grpc.CallOption) (*ListETCNumResponse, error)
	// 車輌IDで取得
	GetByCarID(ctx context.Context, in *GetETCNumByCarIDRequest, opts ...grpc.CallOption) (*ListETCNumResponse, error)
}

type eTCNumServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewETCNumServiceClient(cc grpc.ClientConnInterface) ETCNumServiceClient {
	return &eTCNumServiceClient{cc}
}

func (c *eTCNumServiceClient) List(ctx context.Context, in *ListETCNumRequest, opts ...grpc.CallOption) (*ListETCNumResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListETCNumResponse)
	err := c.cc.Invoke(ctx, ETCNumService_List_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eTCNumServiceClient) GetByETCCardNum(ctx context.Context, in *GetETCNumByETCCardNumRequest, opts ...grpc.CallOption) (*ListETCNumResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListETCNumResponse)
	err := c.cc.Invoke(ctx, ETCNumService_GetByETCCardNum_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eTCNumServiceClient) GetByCarID(ctx context.Context, in *GetETCNumByCarIDRequest, opts ...grpc.CallOption) (*ListETCNumResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListETCNumResponse)
	err := c.cc.Invoke(ctx, ETCNumService_GetByCarID_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ETCNumServiceServer is the server API for ETCNumService service.
// All implementations should embed UnimplementedETCNumServiceServer
// for forward compatibility.
//
// ETCNumサービス - ETCカード番号マスタ管理（本番DB、読み取り専用）
type ETCNumServiceServer interface {
	// ETCカード番号一覧取得
	List(context.Context, *ListETCNumRequest) (*ListETCNumResponse, error)
	// ETCカード番号で取得
	GetByETCCardNum(context.Context, *GetETCNumByETCCardNumRequest) (*ListETCNumResponse, error)
	// 車輌IDで取得
	GetByCarID(context.Context, *GetETCNumByCarIDRequest) (*ListETCNumResponse, error)
}

// UnimplementedETCNumServiceServer should be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedETCNumServiceServer struct{}

func (UnimplementedETCNumServiceServer) List(context.Context, *ListETCNumRequest) (*ListETCNumResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method List not implemented")
}
func (UnimplementedETCNumServiceServer) GetByETCCardNum(context.Context, *GetETCNumByETCCardNumRequest) (*ListETCNumResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetByETCCardNum not implemented")
}
func (UnimplementedETCNumServiceServer) GetByCarID(context.Context, *GetETCNumByCarIDRequest) (*ListETCNumResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetByCarID not implemented")
}
func (UnimplementedETCNumServiceServer) testEmbeddedByValue() {}

// UnsafeETCNumServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ETCNumServiceServer will
// result in compilation errors.
type UnsafeETCNumServiceServer interface {
	mustEmbedUnimplementedETCNumServiceServer()
}

func RegisterETCNumServiceServer(s grpc.ServiceRegistrar, srv ETCNumServiceServer) {
	// If the following call pancis, it indicates UnimplementedETCNumServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&ETCNumService_ServiceDesc, srv)
}

func _ETCNumService_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListETCNumRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ETCNumServiceServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ETCNumService_List_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ETCNumServiceServer).List(ctx, req.(*ListETCNumRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ETCNumService_GetByETCCardNum_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetETCNumByETCCardNumRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ETCNumServiceServer).GetByETCCardNum(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ETCNumService_GetByETCCardNum_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ETCNumServiceServer).GetByETCCardNum(ctx, req.(*GetETCNumByETCCardNumRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ETCNumService_GetByCarID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetETCNumByCarIDRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ETCNumServiceServer).GetByCarID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ETCNumService_GetByCarID_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ETCNumServiceServer).GetByCarID(ctx, req.(*GetETCNumByCarIDRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ETCNumService_ServiceDesc is the grpc.ServiceDesc for ETCNumService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ETCNumService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "ryohi.ETCNumService",
	HandlerType: (*ETCNumServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "List",
			Handler:    _ETCNumService_List_Handler,
		},
		{
			MethodName: "GetByETCCardNum",
			Handler:    _ETCNumService_GetByETCCardNum_Handler,
		},
		{
			MethodName: "GetByCarID",
			Handler:    _ETCNumService_GetByCarID_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "ryohi.proto",
}

const (
	DTakoFerryRowsProdService_Get_FullMethodName         = "/ryohi.DTakoFerryRowsProdService/Get"
	DTakoFerryRowsProdService_List_FullMethodName        = "/ryohi.DTakoFerryRowsProdService/List"
	DTakoFerryRowsProdService_GetByUnkoNo_FullMethodName = "/ryohi.DTakoFerryRowsProdService/GetByUnkoNo"
)

// DTakoFerryRowsProdServiceClient is the client API for DTakoFerryRowsProdService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// DTakoFerryRowsProdサービス - フェリー運行データ管理（本番DB、読み取り専用）
type DTakoFerryRowsProdServiceClient interface {
	// フェリー運行データ取得
	Get(ctx context.Context, in *GetDTakoFerryRowsProdRequest, opts ...grpc.CallOption) (*DTakoFerryRowsProdResponse, error)
	// フェリー運行データ一覧取得
	List(ctx context.Context, in *ListDTakoFerryRowsProdRequest, opts ...grpc.CallOption) (*ListDTakoFerryRowsProdResponse, error)
	// 運行NOでフェリー運行データ取得
	GetByUnkoNo(ctx context.Context, in *GetDTakoFerryRowsProdByUnkoNoRequest, opts ...grpc.CallOption) (*ListDTakoFerryRowsProdResponse, error)
}

type dTakoFerryRowsProdServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewDTakoFerryRowsProdServiceClient(cc grpc.ClientConnInterface) DTakoFerryRowsProdServiceClient {
	return &dTakoFerryRowsProdServiceClient{cc}
}

func (c *dTakoFerryRowsProdServiceClient) Get(ctx context.Context, in *GetDTakoFerryRowsProdRequest, opts ...grpc.CallOption) (*DTakoFerryRowsProdResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DTakoFerryRowsProdResponse)
	err := c.cc.Invoke(ctx, DTakoFerryRowsProdService_Get_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dTakoFerryRowsProdServiceClient) List(ctx context.Context, in *ListDTakoFerryRowsProdRequest, opts ...grpc.CallOption) (*ListDTakoFerryRowsProdResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListDTakoFerryRowsProdResponse)
	err := c.cc.Invoke(ctx, DTakoFerryRowsProdService_List_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dTakoFerryRowsProdServiceClient) GetByUnkoNo(ctx context.Context, in *GetDTakoFerryRowsProdByUnkoNoRequest, opts ...grpc.CallOption) (*ListDTakoFerryRowsProdResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListDTakoFerryRowsProdResponse)
	err := c.cc.Invoke(ctx, DTakoFerryRowsProdService_GetByUnkoNo_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// DTakoFerryRowsProdServiceServer is the server API for DTakoFerryRowsProdService service.
// All implementations should embed UnimplementedDTakoFerryRowsProdServiceServer
// for forward compatibility.
//
// DTakoFerryRowsProdサービス - フェリー運行データ管理（本番DB、読み取り専用）
type DTakoFerryRowsProdServiceServer interface {
	// フェリー運行データ取得
	Get(context.Context, *GetDTakoFerryRowsProdRequest) (*DTakoFerryRowsProdResponse, error)
	// フェリー運行データ一覧取得
	List(context.Context, *ListDTakoFerryRowsProdRequest) (*ListDTakoFerryRowsProdResponse, error)
	// 運行NOでフェリー運行データ取得
	GetByUnkoNo(context.Context, *GetDTakoFerryRowsProdByUnkoNoRequest) (*ListDTakoFerryRowsProdResponse, error)
}

// UnimplementedDTakoFerryRowsProdServiceServer should be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedDTakoFerryRowsProdServiceServer struct{}

func (UnimplementedDTakoFerryRowsProdServiceServer) Get(context.Context, *GetDTakoFerryRowsProdRequest) (*DTakoFerryRowsProdResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedDTakoFerryRowsProdServiceServer) List(context.Context, *ListDTakoFerryRowsProdRequest) (*ListDTakoFerryRowsProdResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method List not implemented")
}
func (UnimplementedDTakoFerryRowsProdServiceServer) GetByUnkoNo(context.Context, *GetDTakoFerryRowsProdByUnkoNoRequest) (*ListDTakoFerryRowsProdResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetByUnkoNo not implemented")
}
func (UnimplementedDTakoFerryRowsProdServiceServer) testEmbeddedByValue() {}

// UnsafeDTakoFerryRowsProdServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to DTakoFerryRowsProdServiceServer will
// result in compilation errors.
type UnsafeDTakoFerryRowsProdServiceServer interface {
	mustEmbedUnimplementedDTakoFerryRowsProdServiceServer()
}

func RegisterDTakoFerryRowsProdServiceServer(s grpc.ServiceRegistrar, srv DTakoFerryRowsProdServiceServer) {
	// If the following call pancis, it indicates UnimplementedDTakoFerryRowsProdServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&DTakoFerryRowsProdService_ServiceDesc, srv)
}

func _DTakoFerryRowsProdService_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetDTakoFerryRowsProdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DTakoFerryRowsProdServiceServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DTakoFerryRowsProdService_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DTakoFerryRowsProdServiceServer).Get(ctx, req.(*GetDTakoFerryRowsProdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DTakoFerryRowsProdService_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListDTakoFerryRowsProdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DTakoFerryRowsProdServiceServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DTakoFerryRowsProdService_List_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DTakoFerryRowsProdServiceServer).List(ctx, req.(*ListDTakoFerryRowsProdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DTakoFerryRowsProdService_GetByUnkoNo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetDTakoFerryRowsProdByUnkoNoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DTakoFerryRowsProdServiceServer).GetByUnkoNo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DTakoFerryRowsProdService_GetByUnkoNo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DTakoFerryRowsProdServiceServer).GetByUnkoNo(ctx, req.(*GetDTakoFerryRowsProdByUnkoNoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// DTakoFerryRowsProdService_ServiceDesc is the grpc.ServiceDesc for DTakoFerryRowsProdService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var DTakoFerryRowsProdService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "ryohi.DTakoFerryRowsProdService",
	HandlerType: (*DTakoFerryRowsProdServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Get",
			Handler:    _DTakoFerryRowsProdService_Get_Handler,
		},
		{
			MethodName: "List",
			Handler:    _DTakoFerryRowsProdService_List_Handler,
		},
		{
			MethodName: "GetByUnkoNo",
			Handler:    _DTakoFerryRowsProdService_GetByUnkoNo_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "ryohi.proto",
}
